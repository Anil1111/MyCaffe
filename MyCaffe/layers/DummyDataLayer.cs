using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MyCaffe.basecode;
using MyCaffe.common;
using MyCaffe.param;
using MyCaffe.fillers;

namespace MyCaffe.layers
{
    /// <summary>
    /// The DummyDataLayer provides data to the Net generated by a Filler.
    /// This layer is initialized with the MyCaffe.param.DummyDataParameter.
    /// </summary>
    /// <typeparam name="T">Specifies the base type <i>float</i> or <i>double</i>.  Using <i>float</i> is recommended to conserve GPU memory.</typeparam>
    public class DummyDataLayer<T> : Layer<T>
    {
        List<Filler<T>> m_rgFillers = new List<Filler<T>>();
        List<bool> m_rgbRefill = new List<bool>();

        /// <summary>
        /// The DummyDataLayer constructor.
        /// </summary>
        /// <param name="cuda">Specifies the CudaDnn connection to Cuda.</param>
        /// <param name="log">Specifies the Log for output.</param>
        /// <param name="p">
        /// Provides DummyDataParameter dummy_data_param with options:
        ///  - data_filler. A list of Fillers to use.
        ///  
        ///  - shape.  A list of shapes to use.
        /// </param>
        public DummyDataLayer(CudaDnn<T> cuda, Log log, LayerParameter p)
            : base(cuda, log, p)
        {
            m_type = LayerParameter.LayerType.DUMMYDATA;
        }

        /// <summary>
        /// Returns 0 for data layers have no bottom (input) Blobs.
        /// </summary>
        public override int ExactNumBottomBlobs
        {
            get { return 0; }
        }

        /// <summary>
        /// Returns the minimum number of required top (output) Blobs: data
        /// </summary>
        public override int MinTopBlobs
        {
            get { return 1; }
        }

        /// <summary>
        /// Setup the layer.
        /// </summary>
        /// <param name="colBottom">Not used.</param>
        /// <param name="colTop">Specifies the collection of top (output) Blobs.</param>
        public override void LayerSetUp(BlobCollection<T> colBottom, BlobCollection<T> colTop)
        {
            int num_top = colTop.Count;
            DummyDataParameter param = m_param.dummy_data_param;
            int num_data_filler = param.data_filler.Count;

            m_log.CHECK(num_data_filler == 0 || num_data_filler == 1 || num_data_filler == num_top, "Number of data fillers must be 0, 1 or equal to the number of tops: " + num_top.ToString() + "; you specified " + num_data_filler.ToString() + " data fillers.");

            bool legacy_dims = (param.num.Count > 0 || param.channels.Count > 0 || param.height.Count > 0 || param.width.Count > 0) ? true : false;

            if (legacy_dims)
            {
                m_log.CHECK_EQ(0, param.shape.Count, "Both shape and legacy fields were specified.");
                // Using depreciated 4D output dim specifiers.
                m_log.CHECK(param.num.Count == 1 || param.num.Count == num_top, "Must specify 'num' once, or once per top blob (" + num_top.ToString() + "); specified " + param.num.Count.ToString() + ".");
                m_log.CHECK(param.channels.Count == 1 || param.channels.Count == num_top, "Must specify 'channels' once, or once per top blob (" + num_top.ToString() + "); specified " + param.channels.Count.ToString() + ".");
                m_log.CHECK(param.height.Count == 1 || param.height.Count == num_top, "Must specify 'height' once, or once per top blob (" + num_top.ToString() + "); specified " + param.height.Count.ToString() + ".");
                m_log.CHECK(param.width.Count == 1 || param.width.Count == num_top, "Must specify 'width' once, or once per top blob (" + num_top.ToString() + "); specified " + param.width.Count.ToString() + ".");
            }

            // refill_[i] tells Forward i whether or not to actually refill top Blob i.
            // if refill_[i] is false, Forward does nothing for Blob i.  We use this to
            // avoid wastefully refilling 'constant' Blobs in every forward pass.
            // We first fill refill_ in with the INVERSE of its final values.
            // The first time we run Forward from the LayerSetup method, we'll fill only
            // Blobs for which refill_ is normally false.  These blobs will never be
            // filled again.
            m_rgbRefill = new List<bool>();
            m_rgFillers = new List<Filler<T>>();

            if (num_data_filler <= 1)
            {
                FillerParameter filler_param;

                if (num_data_filler == 0)
                {
                    filler_param = new FillerParameter("constant");
                    filler_param.value = 0;
                }
                else
                {
                    filler_param = param.data_filler[0].Clone();
                }

                // Refill on each iteration iff not using a constant filler,
                // but use the inverse of this rule for the first run.
                m_rgbRefill.Add((filler_param.type == "constant") ? true : false);
                m_rgFillers.Add(Filler<T>.Create(m_cuda, m_log, filler_param));
            }
            else
            {
                for (int i=0; i<num_top; i++)
                {
                    m_rgFillers.Add(Filler<T>.Create(m_cuda, m_log, param.data_filler[i]));
                    // Refill on each iteration iff not using a constant filler,
                    // but use the inverse of this rule for the first run.
                    m_rgbRefill.Add((param.data_filler[i].type == "constant") ? true : false);
                }
            }

            for (int i=0; i<num_top; i++)
            {
                if (legacy_dims)
                {
                    int num = (int)((param.num.Count == 1) ? param.num[0] : param.num[i]);
                    int channels = (int)((param.channels.Count == 1) ? param.channels[0] : param.channels[i]);
                    int height = (int)((param.height.Count == 1) ? param.height[0] : param.height[i]);
                    int width = (int)((param.width.Count == 1) ? param.width[0] : param.width[i]);
                    colTop[i].Reshape(num, channels, height, width);
                }
                else
                {
                    int shape_index = (param.shape.Count == 1) ? 0 : i;
                    colTop[i].Reshape(param.shape[shape_index]);
                }
            }

            // Run Forward once, with refill_ inverted, to fill the constant blobs.
            Forward(colBottom, colTop);

            // Invert the inverted refill_ values to refill the desired (non-constant)
            // Blobs in every usual forward pass.
            for (int i=0; i<m_rgbRefill.Count; i++)
            {
                m_rgbRefill[i] = !m_rgbRefill[i];
            }
        }

        /// <summary>
        /// Data layers have no bottoms, so reshaping is trivial.
        /// </summary>
        /// <param name="colBottom">Not used.</param>
        /// <param name="colTop">Specifies the collection of top (output) Blobs.</param>
        public override void Reshape(BlobCollection<T> colBottom, BlobCollection<T> colTop)
        {
        }


        /// <summary>
        /// Run the Forward computation, which fills the data into the top (output) Blobs.
        /// </summary>
        /// <param name="colBottom">Not used.</param>
        /// <param name="colTop">top output blob vector (length 1)
        ///  -# @f$ (N \times C \times H \times W) @f$
        ///     the data outputs.  
        /// </param>
        protected override void forward(BlobCollection<T> colBottom, BlobCollection<T> colTop)
        {
            for (int i = 0; i < colTop.Count; i++)
            {
                int filler_id = (m_rgFillers.Count > 1) ? i : 0;

                if (m_rgbRefill[filler_id])
                    m_rgFillers[filler_id].Fill(colTop[i]);
            }
        }

        /// @brief Not implemented - data Layers do not perform backward..
        protected override void backward(BlobCollection<T> colTop, List<bool> rgbPropagateDown, BlobCollection<T> colBottom)
        {
        }
    }
}
